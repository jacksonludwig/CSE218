Misc:
-------
Compares objects.
int compareTo([object]) { } // from interface

	e.g.: a.compareTo(b);

	returns:			when:
	0				a equals b
	negative			a < b
	positive			a > b
----------




Field: indivisible data.
Node: Group of "related" data/fields of field.
Key field: Contents of this field identifies a particular node. Identified by client NOT programmer.
	(Can have more than one, i.e. phonenumber/name COULD be a key for a person and their address, salary, etc).

Homogeneous data set: All nodes have the same fields ("look" the same).
	Insert: adds node
	Fetch: gets node
	Delete: removes node
	Update: replace info of node
Two Access modes: Key field (i.e. fetch(Jones)) and Node number (i.e. fetch(10), like arrays)/fetch();

3 Classes for each program in CSE218:
	Node Definition Class
	Data Structure Class
	Client Application Class
----
Space complexity: Measure of how efficiently the structure uses memory. 
	Quantified as: density, D
		D= information bytes / (total bytes), or:
		D= information bytes / (information bytes + overhead)
			e.g.: 20000/20004 = .96 density
	Maximum: 1 (better)
	Minimum: 0 (worse)
	Normally acceptable densities are usually 0.8+
		This means that 80% of the memory used is from the information bytes.

Speed Complexity: Speed of a data structure's operation algorithms.
	Two measurements: 
		Relative Speed: which of several algorithms is the fastest.
			Algorithms analyzed to determine Big-O (Order of magnitude) value.
				Fastest algorithm is the one with the SMALLEST Big-O value.
					Written as O(...), e.g. O(log2n).
					e.g.: 
						f(n) = 200n + 1000 -> O(n)
						g(n) = 30 + 10n + 2n^2 -> O(n^2)
		Absolute Speed: actual speed of an algorithm in seconds on a platform.
----

Restricted Structures: 
	Two:
		Stack (Top-Bottom)
			LIFO: Last In First Out.
			push = insert
				a failed push is an overflow error.***
				clones made.
			pop = fetch+delete
				a failed pop is an underflow error.***
				no need for clones.
			top = place to pop from next.
			
			other common operations:
				isEmpty(), isFull(), initialize(), showAll(), peek()***, expand().
		Queue (Front-Rear)
			FIFO: First in First Out.
			enqueue = insert
				failed enqueue is also overflow.
			dequeue = fetch/delete
				failed dequeue is also underflow.
			front = place to dequeue from next.
			rear = place to enqueue into next.

			other common operations:
				isEmpty(), isFull(), initialize(), peek(), showall(), expand()
			
			"Circular" queues are used to use garbage collection effectively.
				when rear (or front) equals size - 1, set rear (or front) to 0.
					Use front = (front + 1) % size.
	Operations are RESTRICTED: 
		Only insert and a combination of fetch + delete. May add others rarely.
		Access modes restricted as well: Node number (can't specify which node: just LIFO or FIFO).
	Applications:
		Run time evaluation of math strings:
			infix notation used in code, but POSTFIX notation used at run time.
				[6 * 5] in prefix is [6 5 *] in postfix.
---------------------------
Generics:
	-used to write a method or a class in a way that allows the client code to specify the types of:
		-a method's parameters & returned value,
		-a class's data members, when
		the client invokes the method or declares a class instance.
	-increases reusability
	
	instances of Generic Classes - client side of generics (API's collection):
		Stack<E>, HashMap<L,V>....

	Syntax of Generic void methods:
		signature:
		|	public <T1, T2...> void methodName(T1 param1, T2...)	 |
		|		^type parameter list         ^type placeholders  |
		__________________________________________________________________
		parameter list must contaian all of the placeholders, each separated by a comma.
		Invocation (client side): NO VISIBLE CHANGES.
		Can contain non-generic types as well.
	
		Generic array syntax:
			same as non array generic parameters, but includes "[]".
			e.g. 
				public <T1, T2...> T1[] methodName(T1 param1...) to return array.
				public <T1, T2...> T2 methodName(T2[] param1...) to take in array.
			Invocation is still the same, EXCEPT for primitive data (generic arrays need Double, Integer, etc).

	Operating on generic objects:
		Translator must be able to verify the method's signature.
			**Can use, and override, public methods in Object
			**Can use, and override, public methods in interfaces.
		e.g. 
		public static <T extends Comparable <T>> void methodName(T a, T b) {
			System.out.println(a.equals(b));
			System.out.println(a.compareTo(b));
		}

	Generic Classes:
		Must contain a generic type parameter list
			In heading, immediately after class name.
				e.g.
				public class GenericClass <T1, T2, ...>
			Can, and often do, contain generic methods using the placeholdders,
				data members whose types are the placeholders, etc.
--------------------
Linked Lists:
	Linked lists DO NOT waste space, unlike Array-based Structures 
		(e.g. space for full array is allocated upon creation, even if it isn't used right away).
	Linked lists expand faster, and can contract quickly.
		no empty spaces left after deletion.
	Linked lists do NOT require contiguous memory (can be fragmented), unlike Arrays.
		Allows more efficient use of memory.
	So they are slightly slower, less dense...

	Two common characteristics of all linked lists:
		Every node has an extra field that stores another node's address, called a linked field (often called "next").
			This linked field contains the address to go to next (needed since it's not contiguous)
		Every node's address is stored in at least one other node so it can be accessed.

	Singly Linked List:
		-Each node has one link field
			-There is a unique first node (nothing before)
			-There is a unique last node (nothing after)
			-For all other nodes: a node is preceded by one node, and followed by one node.
				e.g.: beginning/"header"/dummy node0 -> node1 -> node2 -> node3 -> node4/end/"null"
		-Private Reference Data Members with Linked Lists:
			-private inner classes -- NO SETS OR GETS IN ANY LINKED LISTS. Use inner "Node" class and separate Node definition class.
				-private code will be shared
			e.g.:
				public class SinglyLinkedList {
					// private code
					public boolean insert()...etc.
					private class Node {
					    // private code
					}
				}

		-h/header is only variable in SinglyLinkedList class (more can be in node class)
		For sorted singly linked list:
			-insert will be slower.
			-fetch and delete will be twice as fast on average.	
			-one pointer chasing the other
***************
   Sorted methods:
    see project 3
**************

	Doubly linked list:
		-Same as singly linked but have a "back" pointer so traversal can go in both directions.
		-change delete, insert for P3.	
		-showAllBackwards();
	Density:
	nw / ((nw) + 2n + 16)
	1 / (1 + 12n/nw + 16/nw)

--------------

Hashing:
	-Very fast
		-NO SEARCHING -- O(1)
		-h, a manthematical function is used instead -- HASHING function.
		-NEED preproccesing algorithm
			-changes non-numeric key, k, into a numeric pseudo key, pk.
				-key -> preprocess -> pseudo key -> hashing function -> array storage
				-each key maps to unique ip in a Perfect (direct) hashing structure
					-as in, pseudokey = ip.
	-Can be very dense, or not (customize the hashing scheme).
	-Most common structure.
	-ALWAYS O(1), even if not direct/perfect hashing.
	-search length = how many times you look at the array
	
	-Loading factor (current) = nodes currently in array
		(N = size of array)
		-n / N 
	-Max Loading factor = maximum nodes the structure will contain
		-nMax / N

	-Space complexity: (n = nMax, N = size of array, 8 is two variables, 4 is bytes per node)
		D = i / (i + o)
		  = nw / (nw + N * 4 + 8)
		  = 1 / ( 1 + (4N / nw) + (8 / nw))
		  = 1 / (1 + (4/w))

	NON-perfect/indirect hashing:
		-collisions can occur; are possible (UNLIKE perfect/direct hashing)
			-collision algorithm required.
			-different preprocessing and ip algorithm
			-One element of the array for every key that will exist -> the array size N = ?
			-Used to be much more dense, but still fast even if slower than direct.
				-OPTIMUM: nMax / N = 0.75 <- Makes average search ~3 or ~4
			To get Array size (N): 
			-N = nMax / 0.75 (1)
			-N SHOULD BE a prime number (2a)
				-(e.g. if N was 27 (not prime), make N 29 (prime)).
				-FURTHER STILL, it must be a "4k + 3" prime.(2b)
					-so: N = 4k + 3 while k is an integer if N is a 4k + 3 prime.
						-solve for k to determine if it is a 4k + 3 prime.
							-if not, go one more prime until you get one.
								-in summary: N = nMax/ 0.75 increased to the next 4k+3 prime	
									-(reminder: pi product for ?)
				-Preprocessing function: k1k2k3…
					Folding: pk = k1->4 + k5->8 + k9->12 …
				-Hashing function: ip = pk % N;
			-see pg260+261 for FOLDING algorithm

			-collision algorithms:
				-One we will use
					- ip = (ip + offset) % N;
						- LINEAR QUOTIENT version (best)
							-Offset = q = pk / N or a 4k+3 prime
								-must check if q is 0 -- if it is, use 4k+3 prime.
			
			-Delete Problem (same for fetch, update):
				-Use DUMMY node/variable (will keep searching until it finds null, hopping over dummy nodes).
					-v1 = "no address was ever here" (null for our purposes: stop now).
					-v2 = "once was a node here, but it was deleted" (dummy node/object for our purposes: keep going).

			Density:
				- D = i / (i + o)
				    = nMaxw/(nMaxw + 4N + 8)
				    = 1 / (1 + (4N / nMaxw) + (8 / nMaxw))
				    = about 1 / (1 + (4 / w(.75)) [nMax = loading factor, which is always .75 for efficiency]

			-Node not-in-the-structure problem:
				-Occurs when searching for a node that isn't in the array (will search every single node -- BAD)
					-Must not let too many dummies add up (.75 loading factor). Watch Pseudo Loading Factor to make sure it stays below .75, just like normal LF.
						-LF = n / N
						-LF[pseudo] = (n + n[V2]) / N
							-if LF[pseudo] is over .75, fix. 
								-can just use expand without a bigger size. Essentially copy array without dummies.
								-keep a class variable, e.g. numDummies, tracking how many v2/dummy nodes are inserted (happens in delete) and deletes are overwritten (happens in insert).
				
			-see slides for instructions on problem fixes, enhanced methods...


--------------------------

Recursion:
	-Slower, more memory hungary...
	-But can solve a few select problems MUCH easier than it would be without.
	-To understand recursion, factorial:
		loop: n! = n * (n - 1) * (n - 2) .... * 1
		recursion: n! = n * (n - 1) and 1! = 1
	-Base Case, Reduced Problem, General Solution