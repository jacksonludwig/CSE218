Misc:
-------
Compares objects.
int compareTo([object]) { } // from interface

	e.g.: a.compareTo(b);

	returns:			when:
	0				a equals b
	negative			a < b
	positive			a > b
----------




Field: indivisible data.
Node: Group of "related" data/fields of field.
Key field: Contents of this field identifies a particular node. Identified by client NOT programmer.
	(Can have more than one, i.e. phonenumber/name COULD be a key for a person and their address, salary, etc).

Homogeneous data set: All nodes have the same fields ("look" the same).
	Insert: adds node
	Fetch: gets node
	Delete: removes node
	Update: replace info of node
Two Access modes: Key field (i.e. fetch(Jones)) and Node number (i.e. fetch(10), like arrays)/fetch();

3 Classes for each program in CSE218:
	Node Definition Class
	Data Structure Class
	Client Application Class
----
Space complexity: Measure of how efficiently the structure uses memory. 
	Quantified as: density, D
		D= information bytes / (total bytes), or:
		D= information bytes / (information bytes + overhead)
			e.g.: 20000/20004 = .96 density
	Maximum: 1 (better)
	Minimum: 0 (worse)
	Normally acceptable densities are usually 0.8+
		This means that 80% of the memory used is from the information bytes.

Speed Complexity: Speed of a data structure's operation algorithms.
	Two measurements: 
		Relative Speed: which of several algorithms is the fastest.
			Algorithms analyzed to determine Big-O (Order of magnitude) value.
				Fastest algorithm is the one with the SMALLEST Big-O value.
					Written as O(...), e.g. O(log2n).
					e.g.: 
						f(n) = 200n + 1000 -> O(n)
						g(n) = 30 + 10n + 2n^2 -> O(n^2)
		Absolute Speed: actual speed of an algorithm in seconds on a platform.
----

Restricted Structures: 
	Two:
		Stack (Top-Bottom)
			LIFO: Last In First Out.
			push = insert
				a failed push is an overflow error.***
				clones made.
			pop = fetch+delete
				a failed pop is an underflow error.***
				no need for clones.
			top = place to pop from next.
			
			other common operations:
				isEmpty(), isFull(), initialize(), showAll(), peek()***, expand().
		Queue (Front-Rear)
			FIFO: First in First Out.
			enqueue = insert
				failed enqueue is also overflow.
			dequeue = fetch/delete
				failed dequeue is also underflow.
			front = place to dequeue from next.
			rear = place to enqueue into next.

			other common operations:
				isEmpty(), isFull(), initialize(), peek(), showall(), expand()
			
			"Circular" queues are used to use garbage collection effectively.
				when rear (or front) equals size - 1, set rear (or front) to 0.
					Use front = (front + 1) % size.
	Operations are RESTRICTED: 
		Only insert and a combination of fetch + delete. May add others rarely.
		Access modes restricted as well: Node number (can't specify which node: just LIFO or FIFO).
	Applications:
		Run time evaluation of math strings:
			infix notation used in code, but POSTFIX notation used at run time.
				[6 * 5] in prefix is [6 5 *] in postfix.
---------------------------
Generics:
	-used to write a method or a class in a way that allows the client code to specify the types of:
		-a method's parameters & returned value,
		-a class's data members, when
		the client invokes the method or declares a class instance.
	-increases reusability
	
	instances of Generic Classes - client side of generics (API's collection):
		Stack<E>, HashMap<L,V>....

	Syntax of Generic void methods:
		signature:
		|	public <T1, T2...> void methodName(T1 param1, T2...)	 |
		|		^type parameter list         ^type placeholders  |
		__________________________________________________________________
		parameter list must contaian all of the placeholders, each separated by a comma.
		Invocation (client side): NO VISIBLE CHANGES.
		Can contain non-generic types as well.
	
		Generic array syntax:
			same as non array generic parameters, but includes "[]".
			e.g. 
				public <T1, T2...> T1[] methodName(T1 param1...) to return array.
				public <T1, T2...> T2 methodName(T2[] param1...) to take in array.
			Invocation is still the same, EXCEPT for primitive data (generic arrays need Double, Integer, etc).

	Operating on generic objects:
		Translator must be able to verify the method's signature.
			**Can use, and override, public methods in Object
			**Can use, and override, public methods in interfaces.
		e.g. 
		public static <T extends Comparable <T>> void methodName(T a, T b) {
			System.out.println(a.equals(b));
			System.out.println(a.compareTo(b));
		}

	Generic Classes:
		Must contain a generic type parameter list
			In heading, immediately after class name.
				e.g.
				public class GenericClass <T1, T2, ...>
			Can, and often do, contain generic methods using the placeholdders,
				data members whose types are the placeholders, etc.
--------------------
Linked Lists:
	Linked lists DO NOT waste space, unlike Array-based Structures 
		(e.g. space for full array is allocated upon creation, even if it isn't used right away).
	Linked lists expand faster, and can contract quickly.
		no empty spaces left after deletion.
	Linked lists do NOT require contiguous memory (can be fragmented), unlike Arrays.
		Allows more efficient use of memory.
	So they are slightly slower, less dense...

	Two common characteristics of all linked lists:
		Every node has an extra field that stores another node's address, called a linked field (often called "next").
			This linked field contains the address to go to next (needed since it's not contiguous)
		Every node's address is stored in at least one other node so it can be accessed.

	Singly Linked List:
		-Each node has one link field
			-There is a unique first node (nothing before)
			-There is a unique last node (nothing after)
			-For all other nodes: a node is preceded by one node, and followed by one node.
				e.g.: beginning/"header"/dummy node0 -> node1 -> node2 -> node3 -> node4/end/"null"
		-Private Reference Data Members with Linked Lists:
			-private inner classes -- NO SETS OR GETS IN ANY LINKED LISTS. Use inner "Node" class and separate Node definition class.
				-private code will be shared
			e.g.:
				public class SinglyLinkedList {
					// private code
					public boolean insert()...etc.
					private class Node {
					    // private code
					}
				}

		-h/header is only variable in SinglyLinkedList class (more can be in node class)
		For sorted singly linked list:
			-insert will be slower.
			-fetch and delete will be twice as fast on average.	
			-one pointer chasing the other
***************
   Sorted methods:
    public boolean insertSorted(Listing newListing) {
        Node q = h;
        Node p = h.next;
        while (p != null && (p.l.compareTo(newListing.getKey()) < 0)) {
            q = p;
            p = p.next;
        }
        if (p != null) {
            Node n = new Node();
            n.l = newListing.clone();
            n.next = p;
            q.next = n;
            return true;
        }
        return false;
    }
    public boolean deleteSorted(String targetKey) { // same for fetch
        Node q = h;
        Node p = h.next;
        while (p != null && !(p.l.compareTo(targetKey) == 0)) {
            q = p;
            p = p.next;
        }
        if (p != null && !(p.l.compareTo(targetKey) == 0)) { // a hit
            q.next = p.next;
            return true;
        } else {
            return false;
        }
    }
**************

	Doubly linked list:
		-Same as singly linked but have a "back" pointer so traversal can go in both directions.
		-change delete, insert for P3.	
		-showAllBackwards();
	Density:
	nw / ((nw) + 2n + 16)
	1 / (1 + 12n/nw + 16/nw)

--------------

Hashing:
	-Very fast
		-NO SEARCHING -- O(1)
		-h, a manthematical function is used instead -- HASHING function.
		-NEED preproccesing algorithm
			-changes non-numeric key, k, into a numeric pseudo key, pk.
				-key -> preprocess -> pseudo key -> hashing function -> array storage
				-eack key maps to unique ip in a Perfect hashing structure
	-Can be very dense, or not (customize the hashing scheme).
	-Most common structure.
	

	