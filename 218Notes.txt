Field: indivisible data.
Node: Group of "related" data/fields of field.
Key field: Contents of this field identifies a particular node. Identified by client NOT programmer.
	(Can have more than one, i.e. phonenumber/name COULD be a key for a person and their address, salary, etc).

Homogeneous data set: All nodes have the same fields ("look" the same).
	Insert: adds node
	Fetch: gets node
	Delete: removes node
	Update: replace info of node
Two Access modes: Key field (i.e. fetch(Jones)) and Node number (i.e. fetch(10), like arrays)/fetch();

3 Classes for each program in CSE218:
	Node Definition Class
	Data Structure Class
	Client Application Class
----
Space complexity: Measure of how efficiently the structure uses memory. 
	Quantified as: density, D
		D= information bytes / (total bytes), or:
		D= information bytes / (information bytes + overhead)
			e.g.: 20000/20004 = .96 density
	Maximum: 1 (better)
	Minimum: 0 (worse)
	Normally acceptable densities are usually 0.8+
		This means that 80% of the memory used is from the information bytes.

Speed Complexity: Speed of a data structure's operation algorithms.
	Two measurements: 
		Relative Speed: which of several algorithms is the fastest.
			Algorithms analyzed to determine Big-O (Order of magnitude) value.
				Fastest algorithm is the one with the SMALLEST Big-O value.
					Written as O(...), e.g. O(log2n).
					e.g.: 
						f(n) = 200n + 1000 -> O(n)
						g(n) = 30 + 10n + 2n^2 -> O(n^2)
		Absolute Speed: actual speed of an algorithm in seconds on a platform.
----

Restricted Structures: 
	Two:
		Stack (Top-Bottom)
			LIFO: Last In First Out.
			push = insert
				a failed push is an overflow error.***
				clones made.
			pop = fetch+delete
				a failed pop is an underflow error.***
				no need for clones.
			top = place to pop from next.
			
			other common operations:
				isEmpty(), isFull(), initialize(), showAll(), peek()***, expand().
		Queue (Front-Rear)
			FIFO: First in First Out.
			enqueue = insert
				failed enqueue is also overflow.
			dequeue = fetch/delete
				failed dequeue is also underflow.
			front = place to dequeue from next.
			rear = place to enqueue into next.

			other common operations:
				isEmpty(), isFull(), initialize(), peek(), showall(), expand()
			
			"Circular" queues are used to use garbage collection effectively.
				when rear (or front) equals size - 1, set rear (or front) to 0.
					Use front = (front + 1) % size.
	Operations are RESTRICTED: 
		Only insert and a combination of fetch + delete. May add others rarely.
		Access modes restricted as well: Node number (can't specify which node: just LIFO or FIFO).
	Applications:
		Run time evaluation of math strings:
			infix notation used in code, but POSTFIX notation used at run time.
				[6 * 5] in prefix is [6 5 *] in postfix.
---------------------------
Generics:
	-used to write a method or a class in a way that allows the client code to specify the types of:
		-a method's parameters & returned value,
		-a class's data members, when
		the client invokes the method or declares a class instance.
	-increases reusability
	
	instances of Generic Classes - client side of generics (API's collection):
		Stack<E>, HashMap<L,V>....

	Syntax of Generic void methods:
		signature:
		|	public <T1, T2...> void methodName(T1 param1, T2...)	 |
		|		^type parameter list         ^type placeholders  |
		__________________________________________________________________
		parameter list must contaian all of the placeholders, each separated by a comma.
		Invocation (client side): NO VISIBLE CHANGES.
		Can contain non-generic types as well.
	
		Generic array syntax:
			same as non array generic parameters, but includes "[]".
			e.g. 
				public <T1, T2...> T1[] methodName(T1 param1...) to return array.
				public <T1, T2...> T2 methodName(T2[] param1...) to take in array.
			Invocation is still the same, EXCEPT for primitive data (generic arrays need Double, Integer, etc).

	Operating on generic objects:
		Translator must be able to verify the method's signature.
			**Can use, and override, public methods in Object
			**Can use, and override, public methods in interfaces.
		e.g. 
		public static <T extends Comparable <T>> void methodName(T a, T b) {
			System.out.println(a.equals(b));
			System.out.println(a.compareTo(b));
		}

	Generic Classes:
		Must contain a generic type parameter list
			In heading, immediately after class name.
				e.g.
				public class GenericClass <T1, T2, ...>
			Can, and often do, contain generic methods using the placeholdders,
				data members whose types are the placeholders, etc.
			
				